 <!DOCTYPE html>
 <html>
   <head>

     <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>

     <meta charset="utf-8">
     <meta name="viewport" content="width=device-width, initial-scale=1">

     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.1.4/semantic.min.css" type="text/css">
     <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/solarized_light.min.css" rel="stylesheet" />

     <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
     <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.address/1.6/jquery.address.min.js"></script>
     <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.1.4/semantic.min.js"></script>
     <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
     <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/languages/java.min.js"></script>
     <script>hljs.initHighlightingOnLoad();</script>

      <style>


body 
{
  font-family: "Open Sans", "Helvetica", "Helvetica Neue",  "Arial", sans-serif;
}

figcaption
{
  margin-bottom: 20px;
}

.vertical-align
{
  display: flex;
  align-items: center;
}

.credits
{
  min-height:20px;
}
    </style>

  </head>

  <body>

  <div class="ui container">
<style>


code
{
  font-family: "Monaco";
  font-size: 110%;
}

img
{
  padding:1px;
  border:1px solid black;
}

h1
{
  font-style:italic;
  font-size:130%;
  border-bottom: thin solid black;
}
h2
{
  font-size:110%;
  border-bottom: thin solid black;
}
h3
{
  font-size:100%;
  border-bottom: thin solid black;
}

</style>

<div class="ui fixed top pointing inverted menu labmenu">
  <header class="header item">
    <a href="../index.html">
      <i class="sitemap icon"></i>
      Patterns Thinking
    </a>
  </header>
  <div class="right tab-menu menu">
    <a class="active item" data-tab="Lab-06c">
        Lab-06c
    </a>
      <a class="item" data-tab="01">
        01
      </a>
      <a class="item" data-tab="02">
        02
      </a>
      <a class="item" data-tab="03">
        03
      </a>
      <a class="item" data-tab="04">
        04
      </a>
      <a class="item" data-tab="05">
        05
      </a>
      <a class="item" data-tab="06">
        06
      </a>
      <a class="item" data-tab="07">
        07
      </a>
      <a class="item" data-tab="Exercises">
        Exercises
      </a>
    </div>
</div>

<br><br>

  <div  class="ui tab segment lab" data-tab="Lab-06c">
    <h1>Objectives</h1>
<p>Complete the android application to include activity sync support using the Half Sync/Half Async Pattern. Overlay this with a Mediator implementation.</p>
  </div>
  <div  class="ui tab segment lab" data-tab="01">
    <h1>Setup</h1>
<p>This is v5 of the pacemaker-android project from the last lab:</p>
<ul>
<li><a href="https://github.com/wit-design-patterns-2016/pacemaker-android/releases/tag/V5">https://github.com/wit-design-patterns-2016/pacemaker-android/releases/tag/V5</a></li>
</ul>
<p>You can import this for reference purposes, or keep working with your own version.</p>
  </div>
  <div  class="ui tab segment lab" data-tab="02">
    <h1>Registering new Users</h1>
<p>We need re-orient how we connect to the service and synchronise with the user list maintained there.</p>
<p>This approach requires these new methods in PacemakerApp:</p>
<pre><code class="java">  public void connectToPacemakerAPI(Context context)
  {
    PacemakerAPI.getUsers(context, this, &quot;Retrieving list of users&quot;);
  }

  public void registerUser(Context context, User user)
  {
    PacemakerAPI.createUser(context, this, &quot;Registering new user&quot;, user);
  }

  @Override
  public void setResponse(User user)
  {
    connected = true;
    users.put(user.email, user);
    activities.put(user.email, new ArrayList&lt;Activity&gt;());
  }
</code></pre>

<p>And then consequent changes  in Welcome:</p>
<h2>Welcome</h2>
<pre><code class="java">  public void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_welcome);
    app = (PacemakerApp) getApplication();
    app.connectToPacemakerAPI(this);
  }
</code></pre>

<p>And Signup class:</p>
<h2>Signup</h2>
<pre><code class="java">  public void registerPressed (View view) 
  {
    TextView firstName = (TextView)  findViewById(R.id.firstName);
    TextView lastName  = (TextView)  findViewById(R.id.lastName);
    TextView email     = (TextView)  findViewById(R.id.Email);
    TextView password  = (TextView)  findViewById(R.id.Password);

    User user = new User(firstName.getText().toString(), lastName.getText().toString(), email.getText().toString(), password.getText().toString());
    app.registerUser(this, user);

    startActivity (new Intent(this, Login.class));
  }
</code></pre>
  </div>
  <div  class="ui tab segment lab" data-tab="03">
    <h1>Creating Activities</h1>
<p>Extend PacemakerAPI to support creating and retrieval of activities:</p>
<h2>PacemakerAPI</h2>
<pre><code class="java">public class PacemakerAPI
{
  //...

  public static void getActivities(Context context, User user, Response&lt;MyActivity&gt; response, String dialogMesssage)
  {
    new GetActivities(context, user, response, dialogMesssage).execute();
  }

  public static void createActivity(Context context, User user, Response&lt;MyActivity&gt; response, String dialogMesssage, MyActivity activity)
  {
    new CreateActivity(context, user, response, dialogMesssage).execute(activity);
  }
}

//...

class GetActivities extends Request
{
  private User user;

  public GetActivities(Context context, User user, Response&lt;MyActivity&gt; callback, String message)
  {
    super(context, callback, message);
    this.user = user;
  }

  @Override
  protected List&lt;MyActivity&gt; doRequest(Object... params) throws Exception
  {
    String response =  Rest.get(&quot;/api/users/&quot; + user.id + &quot;/activities&quot;);
    List&lt;MyActivity&gt; ActivityList = JsonParser.json2Activities(response);
    return ActivityList;
  }
}

class CreateActivity extends Request
{
  private User user;

  public CreateActivity(Context context, User user, Response&lt;MyActivity&gt; callback, String message)
  {
    super(context, callback, message);
    this.user = user;
  }

  @Override
  protected MyActivity doRequest(Object... params) throws Exception
  {
    String response = Rest.post (&quot;/api/users/&quot; + user.id + &quot;/activities&quot;, JsonParser.activity2Json(params[0]));
    return JsonParser.json2Activity(response);
  }
}
</code></pre>

<p>We now encapsulate access to this feature in the application Facade:</p>
<h2>PacemakerApp</h2>
<pre><code class="java">  public void createActivity (Context context, MyActivity activity, Response&lt;MyActivity&gt; responder)
  {
    if (loggedInUser != null)
    {
      PacemakerAPI.createActivity(context, loggedInUser, responder, &quot;Creating activity...&quot;, activity);
    }
  }

  public void getActivities(Context context, Response&lt;MyActivity&gt; responder)
  {
    PacemakerAPI.getActivities(context, loggedInUser, responder, &quot;Retrieving Activities...&quot;);
  }
</code></pre>
  </div>
  <div  class="ui tab segment lab" data-tab="04">
    <h1>Controllers</h1>
<p>The activities list controller can now retrieve/update activities from the service</p>
<h2>ActivitiesList</h2>
<pre><code class="java">
public class ActivitiesList extends  android.app.Activity implements Response &lt;MyActivity&gt; 
{
  private PacemakerApp     app;
  private ListView         activitiesListView;
  private ActivityAdapter  activitiesAdapter;
  private List&lt;MyActivity&gt; activities = new ArrayList&lt;MyActivity&gt;();

  @Override 
  protected void onCreate(Bundle savedInstanceState) 
  {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_activities_list);

    app = (PacemakerApp) getApplication();

    activitiesListView = (ListView) findViewById(R.id.activitiesListView);
    activitiesAdapter = new ActivityAdapter(this, activities);
    activitiesListView.setAdapter(activitiesAdapter);

    app.getActivities(this, this);
  }


  @Override
  public void setResponse(List&lt;MyActivity&gt; aList) 
  {
    activitiesAdapter.activities = aList;
    activitiesAdapter.notifyDataSetChanged();
  }

  @Override
  public void setResponse(MyActivity anObject) 
  {
  }

  @Override
  public void errorOccurred(Exception e) 
  {
    Toast toast = Toast.makeText(this, &quot;Error Retrieving Activities...&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }
}

//...
</code></pre>

<p>Similarly, we can create an activity using the new features on the app class:</p>
<h2>CreateActivity</h2>
<pre><code class="java">public class CreateActivity extends android.app.Activity implements Response &lt;MyActivity&gt;
{
  //...
  //...

  public void createActivityButtonPressed (View view)
  {  
    double distance = distancePicker.getValue();
    Activity activity = new Activity (activityType.getText().toString(), activityLocation.getText().toString(), distance);

    app.createActivity(this, activity, this);
  }

  @Override
  public void setResponse(List&lt;MyActivity&gt; aList)
  {}

  @Override
  public void setResponse(MyActivity anObject)
  {}

  @Override
  public void errorOccurred(Exception e)
  {
    Toast toast = Toast.makeText(this, &quot;Failed to create Activity&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }
</code></pre>

<p>Test this now and verify that web and android are in sync. You should be able to create activities in either the web app or the android app, and both lists should be visible on each platform.</p>
<p>This is the app at this stage:</p>
<ul>
<li><a href="https://github.com/wit-design-patterns-2016/pacemaker-android/releases/tag/V6">https://github.com/wit-design-patterns-2016/pacemaker-android/releases/tag/V6</a></li>
</ul>
<p>Make sure you can follow the flow of information to/from the service.</p>
  </div>
  <div  class="ui tab segment lab" data-tab="05">
    <h1>Mediator</h1>
<p>We could attempt to rationalize the syncing - by introducing a <code>mediator</code> to encapsulate thte sync behaviour.</p>
<p>First, introduce a new interface to encapsulate more generic sync events:</p>
<pre><code class="java">package org.pacemaker.main;

public interface SyncUpdate
{
  void userSyncComplete();
  void activitiesSyncComplete();
  void syncError (Exception e);
}
</code></pre>

<p>Then we introduce a Mediator class to hide access to the API:</p>
<pre><code class="java">package org.pacemaker.main;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.pacemaker.http.Response;
import org.pacemaker.models.MyActivity;
import org.pacemaker.models.MyActivity;
import org.pacemaker.models.User;

import android.content.Context;
import android.widget.Toast;

public class PacemakerMediator
{
  Context                     context;
  SyncUpdate                  syncUpdate;
  Map&lt;String, User&gt;           users             = new HashMap&lt;String, User&gt;();
  Map&lt;String, List&lt;MyActivity&gt;&gt; activities      = new HashMap&lt;String, List&lt;MyActivity&gt;&gt;();
  UserResponder               userResponder     = new UserResponder(this);
  ActivityResponder           activityResponder = new ActivityResponder(this);  

  public User getUser(String email)
  {
    return users.get(email);
  }

  public List&lt;MyActivity&gt; getActivities(User user)
  {
    return activities.get(user.email);
  }

  public void registerUser(Context context, User user, SyncUpdate syncUpdate)
  { 
    this.syncUpdate = syncUpdate;
    PacemakerAPI.createUser(context, userResponder, &quot;Creating new User...&quot;, user);
  }

  public void createActivity(User user, MyActivity activity, SyncUpdate syncUpdate)
  {
    this.syncUpdate = syncUpdate;
    PacemakerAPI.createActivity(context, user, activityResponder, &quot;Creating new Activity...&quot;, activity);
  }

  void syncUsers(Context context, SyncUpdate syncUpdate)
  {
    this.context    = context;
    this.syncUpdate = syncUpdate;
    PacemakerAPI.getUsers(context, userResponder, &quot;Syncing Users&quot;);
  }

  void syncActivities(User user, SyncUpdate syncUpdate)
  {
    this.syncUpdate = syncUpdate;
    activityResponder.user = user;
    PacemakerAPI.getActivities(context, user, activityResponder, &quot;Syncing Activities&quot;);   
  }

  void error(Exception e)
  {
    Toast toast = Toast.makeText(context, &quot;Error in communicating with Pacemaker&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }
}

class UserResponder implements Response&lt;User&gt;
{
  PacemakerMediator mediator;

  UserResponder (PacemakerMediator pacemakerMediator)
  {
    this.mediator = pacemakerMediator;   
  }

  @Override
  public void setResponse(List&lt;User&gt; users)
  {
    for (User user : users)
    {
      mediator.users.put(user.email, user);
    }
    mediator.syncUpdate.userSyncComplete();
  }

  @Override
  public void setResponse(User user)
  {
    mediator.users.put(user.email, user);
    mediator.activities.put(user.email, new ArrayList&lt;MyActivity&gt;());
    mediator.syncUpdate.userSyncComplete();
  }

  @Override
  public void errorOccurred(Exception e)
  {
    mediator.error(e);
  }
}

class ActivityResponder implements Response&lt;MyActivity&gt;
{
  PacemakerMediator mediator;
  User              user;

  ActivityResponder (PacemakerMediator mediator)
  {
    this.mediator = mediator;   
  }

  @Override
  public void setResponse(List&lt;MyActivity&gt; activities)
  {
    mediator.activities.put(user.email, activities);
    mediator.syncUpdate.activitiesSyncComplete();
  }

  @Override
  public void setResponse(MyActivity activity)
  {
    mediator.activities.get(user.email).add(activity);
    mediator.syncUpdate.activitiesSyncComplete();
  }

  @Override
  public void errorOccurred(Exception e)
  {
    mediator.error(e);
  }
}

</code></pre>
  </div>
  <div  class="ui tab segment lab" data-tab="06">
    <h1>PacemakerApp</h1>
<p>With the mediator in place, refactor PacemakerApp to use the mediator:</p>
<pre><code class="java">package org.pacemaker.main;

import java.util.List;
import org.pacemaker.models.MyActivity;
import org.pacemaker.models.User;
import android.app.Application;
import android.content.Context;
import android.util.Log;
import android.widget.Toast;

public class PacemakerApp extends Application implements  SyncUpdate
{
  private User              loggedInUser;
  private PacemakerMediator mediator = new PacemakerMediator();

  public void syncUsers(Context context)
  {
    mediator.syncUsers(context, this);
  }

  public void registerUser(User user, Context context)
  {
    mediator.registerUser(context, user, this);
  }

  public List&lt;MyActivity&gt; getActivities()
  {
    return mediator.getActivities(loggedInUser);
  }

  public boolean loginUser(String email, String password)
  {
    loggedInUser = mediator.getUser(email);
    if (loggedInUser != null &amp;&amp; !loggedInUser.password.equals(password))
    {
      loggedInUser = null;
    }
    mediator.syncActivities(loggedInUser, this);
    return loggedInUser != null;
  }

  public void logout()
  {
    loggedInUser = null;
  }

  public void createActivity (Context context, MyActivity activity, SyncUpdate syncUpdate)
  {
    if (loggedInUser != null)
    {
      mediator.createActivity(loggedInUser, activity, syncUpdate);
    }
  }

  @Override
  public void userSyncComplete()
  {
    Toast toast = Toast.makeText(this, &quot;Pacemaker Sync Successful&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }

  @Override
  public void activitiesSyncComplete()
  {
    Toast toast = Toast.makeText(this, &quot;Pacemaker Sync Successful&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }

  @Override
  public void syncError(Exception e)
  {
    Toast toast = Toast.makeText(this, &quot;Failed to connect to Pacemaker Service&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }

  @Override
  public void onCreate()
  {
    super.onCreate();
    Log.v(&quot;Pacemaker&quot;, &quot;Pacemaker App Started&quot;);
  }
}

</code></pre>
  </div>
  <div  class="ui tab segment lab" data-tab="07">
    <h1>Controllers</h1>
<p>The controllers can now be relieved for responsibility for accessing the API in a fine grained manner, and use the Mediator we have just introduced:</p>
<h2>Welcome</h2>
<pre><code class="java">  public void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_welcome);
    app = (PacemakerApp) getApplication();
    app.syncUsers(this);
  }
</code></pre>

<h2>Signup</h2>
<pre><code class="java">  public void registerPressed (View view)
  {
    TextView firstName = (TextView)  findViewById(R.id.firstName);
    TextView lastName  = (TextView)  findViewById(R.id.lastName);
    TextView email     = (TextView)  findViewById(R.id.Email);
    TextView password  = (TextView)  findViewById(R.id.Password);

    User user = new User (firstName.getText().toString(), lastName.getText().toString(), email.getText().toString(), password.getText().toString());
    app.registerUser(user, this);
    startActivity (new Intent(this, Login.class));
  }
</code></pre>

<h2>CreateActivity</h2>
<pre><code class="java">package org.pacemaker.controllers;

import org.pacemaker.R;
import org.pacemaker.main.PacemakerApp;
import org.pacemaker.main.SyncUpdate;
import org.pacemaker.models.MyActivity;
import org.pacemaker.models.MyActivity;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.NumberPicker;
import android.widget.TextView;
import android.widget.Toast;

public class CreateActivity extends android.app.Activity implements SyncUpdate
{
  private PacemakerApp   app;
  private Button         createActivityButton;
  private TextView       activityType;
  private TextView       activityLocation;
  private NumberPicker   distancePicker;

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_create);

    app = (PacemakerApp) getApplication();

    createActivityButton = (Button)       findViewById(R.id.createActivityButton);
    activityType         = (TextView)     findViewById(R.id.activityType);
    activityLocation     = (TextView)     findViewById(R.id.activityLocation);
    distancePicker       = (NumberPicker) findViewById(R.id.numberPicker);

    distancePicker.setMinValue(0);
    distancePicker.setMaxValue(20);
  }

  public void createActivityButtonPressed (View view)
  {
    double distance     = distancePicker.getValue();
    MyActivity activity = new MyActivity (activityType.getText().toString(), activityLocation.getText().toString(), distance);

    app.createActivity(this, activity, this);
  }

  @Override
  public void userSyncComplete()
  { }

  @Override
  public void activitiesSyncComplete()
  {
    Toast toast = Toast.makeText(this, &quot;Activity Created&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }

  @Override
  public void syncError(Exception e)
  {
    Toast toast = Toast.makeText(this, &quot;Failed to create Activity&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }

  public void listActivityButtonPressed (View view)
  {
    Log.v(&quot;Pacemaker&quot;, &quot;List Activities Button Pressed&quot;);
    startActivity (new Intent(this, ActivitiesList.class));
  }
}
</code></pre>

<h2>ActivitiesList</h2>
<pre><code class="java">package org.pacemaker.controllers;


import java.util.ArrayList;
import java.util.List;

import org.pacemaker.R;
import org.pacemaker.main.PacemakerApp;
import org.pacemaker.main.SyncUpdate;
import org.pacemaker.models.MyActivity;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;


public class ActivitiesList extends  android.app.Activity implements SyncUpdate
{
  private PacemakerApp     app;
  private ListView         activitiesListView;
  private ActivityAdapter  activitiesAdapter;
  private List&lt;MyActivity&gt; activities = new ArrayList&lt;MyActivity&gt;();

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_activities_list);

    app = (PacemakerApp) getApplication();

    activitiesListView = (ListView) findViewById(R.id.activitiesListView);
    activitiesAdapter = new ActivityAdapter(this,  activities);
    activitiesListView.setAdapter(activitiesAdapter);
    activitiesAdapter.activities = app.getActivities();
    activitiesAdapter.notifyDataSetChanged();
  }

  @Override
  public void userSyncComplete()
  { }

  @Override
  public void activitiesSyncComplete()
  {
    activitiesAdapter.activities = app.getActivities();
    activitiesAdapter.notifyDataSetChanged();
  }

  @Override
  public void syncError(Exception e)
  {
    Toast toast = Toast.makeText(this, &quot;Error Retrieving Activities...&quot;, Toast.LENGTH_SHORT);
    toast.show();
  }
}

class ActivityAdapter extends ArrayAdapter&lt;MyActivity&gt;
{
  private Context        context;
  public  List&lt;MyActivity&gt; activities;

  public ActivityAdapter(Context context, List&lt;MyActivity&gt; activities)
  {
    super(context, R.layout.activity_row_layout, activities);
    this.context   = context;
    this.activities = activities;
  }

  @Override
  public View getView(int position, View convertView, ViewGroup parent)
  {
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

    View       view      = inflater.inflate(R.layout.activity_row_layout, parent, false);
    MyActivity activity  = activities.get(position);
    TextView   type      = (TextView) view.findViewById(R.id.type);
    TextView   location  = (TextView) view.findViewById(R.id.location);
    TextView   distance  = (TextView) view.findViewById(R.id.distance);

    type.setText(activity.kind);
    location.setText(activity.location);
    distance.setText(&quot;&quot; + activity.distance);
    return view;
  }

  @Override
  public int getCount()
  {
    return activities.size();
  }
}
</code></pre>

<p>Try the andorid app again now - it should work as before. However, the interaction with the Facade now shields the Activities from the mechanics of the REST access.</p>
  </div>
  <div  class="ui tab segment lab" data-tab="Exercises">
    <h1>Exercises</h1>
<p>Archive of the app so far:</p>
<ul>
<li><a href="https://github.com/wit-design-patterns-2016/pacemaker-android/releases/tag/V7">https://github.com/wit-design-patterns-2016/pacemaker-android/releases/tag/V7</a></li>
</ul>
<p>This lab has introduce the Mediator pattern in an attempt to introduce a generic 'sync' feature. There are a range of features in the Android SDK which could be exploited by the Mediator implementation - or which could replace the mediator completely, implementing a more robust sync facility. These are concepts that can usefully implemented in your assignment. Among these are:</p>
<h2><a href="http://developer.android.com/guide/components/services.html">Services</a></h2>
<blockquote>
<p>A Service is an application component that can perform long-running operations in the background and does not provide a user interface. Another application component can start a service and it will continue to run in the background even if the user switches to another application</p>
</blockquote>
<p>Currently, for every command a new thread is being created vie the <code>AsyncTask</code> execute method:</p>
<pre><code class="java">    new GetActivities(context, user, response, dialogMesssage).execute();
</code></pre>

<p>(Note the '.execute' above). Unless we specifically initiate a command like this from the android client, we will not revieve any updates. We could initiate a service on application launch, which would periodically reach out to the service and download any updates. In this way, if a user updated activities using the web app, then should appear on the android client in due course.</p>
<h2><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html">BroadcastRecievers</a></h2>
<p>If you implement the services above, then your activities will need to be updated periodically if a change is noticed. BroadcastRecievers are one way of achieving this. It may even be possible for multiple applications to 'register' for activity updates using this mechanism</p>
<h2><a href="http://developer.android.com/training/sync-adapters/creating-sync-adapter.html">SyncAdapter</a></h2>
<blockquote>
<p>The sync adapter component in your app encapsulates the code for the tasks that transfer data between the device and a server. Based on the scheduling and triggers you provide in your app, the sync adapter framework runs the code in the sync adapter component.</p>
</blockquote>
<p>Supplementing the above, the SyncAdapter framework introduces a more comprehensive solution to sync issues:</p>
  </div>
<script>
$('.ui.menu .item')
  .tab({
    history: true,
    historyType: 'hash'
  })
;
</script>
   </div>



  <br><br>
  <div class="ui bottom fixed borderless menu">
    <div class="ui small item">
    <p id="footertext">
    Prepared by  Eamonn de Leastar (edeleastar@wit.ie). Except where otherwise noted, this content is licensed under a
     <a  href="http://creativecommons.org/licenses/by-nc/4.0/" title="External link to http://creativecommons.org/licenses/by-nc/4.0/"
       target="_blank">Creative Commons Attribution-NonCommercial 4.0 License
     </a>
     </p>
    </div>
  </div>    <script>

$(document).ready(function()
{
  $("img").addClass ("ui image");

  var images = $(".lab img");
  jQuery.each(images, function(i)  {
    if((images[i].alt).length > 0)
    {
      var div_img = $(document.createElement("div")).addClass("ui segment");
      $(images[i]).wrap(div_img);
      var div_label = $(document.createElement("div")).addClass("ui ribbon teal top attached label");
      div_label.append(images[i].alt);
      $(div_label).insertBefore(images[i]);
    }
  });
})    </script>

  </body>
 </html>